//2 questions in between levels.
module game_main (
    input clk,              // 100MHz clock
    input rst,
    output custom_seg [8],
    output custom_sel [5],
    output input_sel [1],
    output input_seg [8],
    output led_lives[3],
    
    input increase_button[1],
    input decrease_button[1],
    
    input start_switch[1],
    input enter_switch[1],
    input reset_switch[1],
    input onoff_switch[1]
    ) {
  
  //connector for displays of correct answer chosen
  sig display0[5];
  sig display1[5];
  sig display2[5];
  sig display3[5];
  sig display4[5];
  
  .clk(clk) {
  
    edge_detector normal_edge(#RISE(1),#FALL(0));
    edge_detector rng_edge (#RISE(1),#FALL(0));
    
    .rst(rst){
      
      //for display
      modified_counter ctr;
      
      //rng
      pn_gen rng;      
      counter rng_clock(#SIZE(1),#DIV(1)); 
      
      counter normal_clock(#SIZE(1),#DIV(27));
      
      //all fsm and dff
      fsm state={IDLE,    //IDLE = INITIALISATION OF CORRECT COUNT AND ALL DISPLAYS
      START,              //START = RESET LIVES COUNT AND TRANSITION BETWEEN DIFFICULTY QUESTION
      INSERT,             //INSERT = STATE IN WHICH USER INPUTS HIS/HER ANSWER
      INIT_SET_QNS1,SET_QNS10,SET_QNS11,SET_QNS12,SET_QNS13,SET_QNS14, //SET QUESTION FOR difficulty1
      INIT_SET_QNS2,SET_QNS20,SET_QNS21,SET_QNS22,SET_QNS23,SET_QNS24, //SET QUESTION FOR difficulty2
      INIT_SET_QNS3,SET_QNS30,SET_QNS31,SET_QNS32,SET_QNS33,SET_QNS34, //SET QUESTION FOR difficulty3
      CHECK0,CHECK1,CHECK2,CHECK3,CHECK4, //TO CHECK ANSWER
      COMBINE0,COMBINE1,COMBINE2,COMBINE3,COMBINE4, //TO CREATE NEW DISPLAY BASED ON CORRECT INPUT
      SET_OUT0,SET_OUT1,SET_OUT2,SET_OUT3,SET_OUT4, //TO MAKE SIGNAL OUT=1 IF INPUT IS CORRECT
      CHECK, //TRANSITION BETWEEN SUBTRACT LIVES (IF WRONG) OR GET_DISPLAY_STATE (IF CORRECT) 
      TEMP_WIN, //FOR WHEN THE QUESTION IS ODD NUMBER (IN BETWEEN LEVELS)
      LEVEL2,LEVEL3,WIN,LOSE, //DISPLAYS LEVEL2,LEVEL3,WIN,LOSE ON THE 7 SEG
      GET_DISPLAY_STATE, //IF ALL LETTERS GUESSED CORRECTLY : GO TO ADD_CORRECT_COUNT , ELSE : GO TO INSERT
      ADD_CORRECT_COUNT, //ADD CORRECT COUNT, GO TO GET_CORRECT_COUNT
      GET_CORRECT_COUNT, //TRANSITION BETWEEN LEVELS BASED ON CORRECT COUNT
      SUBTRACT_LIVES, //DECREASE LIVES IF WRONG
      GET_LIVES}; //IF LIVES == 0 : LOSE, ELSE : GO INSERT
        
      dff display_state[5]; //to display state of correct letters
      dff current_input[5]; //to store user's input value
      dff question0[5]; //question letter 1
      dff question1[5]; //question letter 2
      dff question2[5]; //question letter 3
      dff question3[5]; //question letter 4
      dff question4[5]; //question letter 5
      dff lives[2]; //set to 3 lives
      dff out[1]; //if wrong =0 , if correct =1
      dff off[1]; //to turn off display
      dff rng_num[4]; //for question.rng input
      dff correct_count[4]; //to count no of correct qns answered (to switch between levels)
      multi_seven_seg multi_seg; //for seven_seg display
      
      }
  }
  seven_seg seg;           //for user_input seven_seg display
  alu alu;
  
  //questions of each difficulty
  difficulty1 difficulty1; 
  difficulty2 difficulty2;
  difficulty3 difficulty3;
  
  always {
    //to generate random number to randomize question
    rng.seed=c{8b1,8b0,8b0,8b1}; //can be any 32 bit value
    rng_edge.in=rng_clock.value; 
    rng.next=rng_edge.out;
    
    //initialise questions
    difficulty1.rng=rng_num.q;
    difficulty2.rng=rng_num.q;
    difficulty3.rng=rng_num.q;
    
    ctr.increase_button=increase_button;
    ctr.decrease_button=decrease_button;
    
    normal_edge.in=normal_clock.value;
    
    //to display user's input in blue seven seg display
    seg.char=ctr.out;    //letter increases/decreases every time the button is pressed
    input_sel=1b0;
    input_seg=seg.segs;
    
    //to always display correct letter chosen
    display0=0;
    display1=0;
    display2=0;
    display3=0;
    display4=0;
    if (display_state.q[0]){display0=question0.q;}
    if (display_state.q[1]){display1=question1.q;}
    if (display_state.q[2]){display2=question2.q;}
    if (display_state.q[3]){display3=question3.q;}
    if (display_state.q[4]){display4=question4.q;}  
    multi_seg.values={display0,display1,display2,display3,display4};
    
    custom_seg=multi_seg.seg;
    custom_sel=~multi_seg.sel;
  
    //alu initialisation
    alu.a=16b0;
    alu.b=16b0;
    alu.alufn=6b0;
    
    //displaying of lives
    led_lives=b000;
    if (lives.q==b10){led_lives=b001;}
    if (lives.q==b01){led_lives=b011;}
    if (lives.q==b00){led_lives=b111;}
    
    //to turn on/off display
    if(onoff_switch){
      off.d=0;
    }
    if (!off.q){
      state.d=state.IDLE;
      if(onoff_switch){
      off.d=1;
      }
    }
    
    //if reset switch button is pressed, the user's input is resetted
    ctr.reset_to_zero=0;
    if (reset_switch){
      state.d=state.IDLE;
    }
    
    
    case(state.q){
      //to prevent error
      default:
        state.d=state.IDLE;
        
      //idle state that reset correct count and input display back to letter "A" and turn off all displays.
      state.IDLE: 
      
        custom_sel=5b11111;
        input_sel=1b1;
        led_lives=3b111;
        
        correct_count.d=4b0;
        ctr.reset_to_zero=1;    
        state.d=state.START;
      
      //set question and reset display_state and no of lives
      state.START: 
        
        multi_seg.values={5d19,5d20,5d1,5d18,5d20}; //START
        
        display_state.d=5b0;
        rng_num.d=rng.num; 
    
         if ( correct_count.q > d0 ){
            
              if ( correct_count.q < d2){state.d=state.INIT_SET_QNS1;}
            
              else if ( correct_count.q < d4){state.d=state.INIT_SET_QNS2;}
            
              else if ( correct_count.q < d6){state.d=state.INIT_SET_QNS3;}
            
        }

        //set initial lives value
        lives.d=b11;
        
        if (start_switch){
          state.d=state.INIT_SET_QNS1;
        }
      
      state.INIT_SET_QNS1:
        difficulty1.rng=rng_num.q;
        state.d=state.SET_QNS10;
        
      state.SET_QNS10:
        question0.d=difficulty1.question0;
        state.d=state.SET_QNS11;
          
      state.SET_QNS11:
        question1.d=difficulty1.question1;
        state.d=state.SET_QNS12;
          
      state.SET_QNS12:
        question2.d=difficulty1.question2;
        state.d=state.SET_QNS13;
          
      state.SET_QNS13:
        question3.d=difficulty1.question3;
        state.d=state.SET_QNS14;
          
      state.SET_QNS14:
        question4.d=difficulty1.question4;
        state.d=state.INSERT;
          
     state.INIT_SET_QNS2:
        difficulty2.rng=rng_num.q;
        state.d=state.SET_QNS20;
        
      state.SET_QNS20:
        question0.d=difficulty2.question0;
        state.d=state.SET_QNS21;
          
      state.SET_QNS21:
        question1.d=difficulty2.question1;
        state.d=state.SET_QNS22;
          
      state.SET_QNS22:
        question2.d=difficulty2.question2;
        state.d=state.SET_QNS23;
          
      state.SET_QNS23:
        question3.d=difficulty2.question3;
        state.d=state.SET_QNS24;
          
      state.SET_QNS24:
        question4.d=difficulty2.question4;
        state.d=state.INSERT;
        
      state.INIT_SET_QNS3:
        difficulty3.rng=rng_num.q;
        state.d=state.SET_QNS30;
        
      state.SET_QNS30:
        question0.d=difficulty3.question0;
        state.d=state.SET_QNS31;
          
      state.SET_QNS31:
        question1.d=difficulty3.question1;
        state.d=state.SET_QNS32;
          
      state.SET_QNS32:
        question2.d=difficulty3.question2;
        state.d=state.SET_QNS33;
          
      state.SET_QNS33:
        question3.d=difficulty3.question3;
        state.d=state.SET_QNS34;
          
      state.SET_QNS34:
        question4.d=difficulty3.question4;
        state.d=state.INSERT;
      
      
      //store user's input in current_input dff.
      state.INSERT: 
        current_input.d=ctr.out;          //user's input using increase n decrease button
        out.d=0; 
        if (enter_switch){
          state.d=state.CHECK0;
        }
          
      //check whether the answer is valid
      state.CHECK0:
        alu.a=current_input.q;
        alu.b=question0.q;
        alu.alufn=b110011;    //CMPEQ
        if (alu.out){
          state.d=state.COMBINE0;
          }
        else{
          state.d=state.CHECK1;
          }
        
      state.CHECK1:       
        alu.a=current_input.q;
        alu.b=question1.q;
        alu.alufn=b110011;
        if (alu.out){
          state.d=state.COMBINE1;
          }
        else{
          state.d=state.CHECK2;
          } 
        
      state.CHECK2:
        alu.a=current_input.q;
        alu.b=question2.q;
        alu.alufn=b110011;
        if (alu.out){
          state.d=state.COMBINE2;
          }
        else{
          state.d=state.CHECK3;
          } 
        
      state.CHECK3:
        alu.a=current_input.q;
        alu.b=question3.q;
        alu.alufn=b110011;
        if (alu.out){
          state.d=state.COMBINE3;
          }
        else{
          state.d=state.CHECK4;
          }
         
      state.CHECK4:
        alu.a=current_input.q;
        alu.b=question4.q;
        alu.alufn=b110011;
        if (alu.out){
          state.d=state.COMBINE4;
          }
        else{
          state.d=state.CHECK;
          }
       
      state.COMBINE0:
        alu.a=display_state.q;
        alu.b=b00001;
        alu.alufn=b010111;    //OR
        display_state.d=alu.out;
        state.d=state.SET_OUT0;
      
      state.SET_OUT0:
        out.d=1;
        state.d=state.CHECK1;
        
      state.COMBINE1:
        alu.a=display_state.q;
        alu.b=b00010;
        alu.alufn=b010111;
        display_state.d=alu.out;
        state.d=state.SET_OUT1;
      
      state.SET_OUT1:
        out.d=1;
        state.d=state.CHECK2;
        
      state.COMBINE2:
        alu.a=display_state.q;
        alu.b=b00100;
        alu.alufn=b010111;
        display_state.d=alu.out;
        state.d=state.SET_OUT2;
      
      state.SET_OUT2:
        out.d=1;
        state.d=state.CHECK3;
      
      state.COMBINE3:
        alu.a=display_state.q;
        alu.b=b01000;
        alu.alufn=b010111;
        display_state.d=alu.out;
        state.d=state.SET_OUT3;
      
      state.SET_OUT3:
        out.d=1;
        state.d=state.CHECK4;
        
      state.COMBINE4:
        alu.a=display_state.q;
        alu.b=b10000;
        alu.alufn=b010111;
        display_state.d=alu.out;
        state.d=state.SET_OUT4;
      
      state.SET_OUT4:
        out.d=1;
        state.d=state.CHECK;
        
      //If wrong, subtract lives. If correct, get display state to check if question is completed
      state.CHECK:       
        if (out.q){
          state.d=state.GET_DISPLAY_STATE;
          }
        
        else{
          state.d=state.SUBTRACT_LIVES;
        }
        
        
      //happens when the question attempted is odd number (in between levels)
      state.TEMP_WIN:
        
        multi_seg.values={5d18,5d9,5d7,5d8,5d20}; //RIGHT
        lives.d=2b11;
        
        if (normal_edge.out){
          state.d=state.START;
          }
      
      //displays level 2    
      state.LEVEL2:
        
        multi_seg.values={5d12,5d5,5d22,5d5,5d12}; //LEVEL 2
        seg.char=d26; // 2
        led_lives=b000;
        if (normal_edge.out){
          state.d=state.START;
          }
      
      //displays level 3  
      state.LEVEL3:
      
        multi_seg.values={5d12,5d5,5d22,5d5,5d12}; //LEVEL 3
        seg.char=d27; // 3
        led_lives=b000;
        if (normal_edge.out){
          state.d=state.START;
          }
          
      //Player wins and goes back to IDLE state
      state.WIN:
        multi_seg.values={5d0,5d0,5d23,5d9,5d14}; //WIN
        seg.char=0;
        led_lives=b000;
        if (start_switch){
          state.d=state.IDLE;
        }
        
      //Player loses and goes back to IDLE state
      state.LOSE:
        multi_seg.values={5b0,5d12,5d15,5d19,5d5}; //LOSE
        seg.char=0;
        
        if (start_switch){
          state.d=state.IDLE;
        }
      
      //If all letters are guessed correctly: go to ADD_CORRECT_COUNT. Else: go back to INSERT state.    
      state.GET_DISPLAY_STATE:
          if (display_state.q==5b11111){
            state.d=state.ADD_CORRECT_COUNT;
          }
          else{
            state.d=state.INSERT;
          }
      
      //Add correct count to track which level the players are in.  
      state.ADD_CORRECT_COUNT:
          alu.a=correct_count.q;
          alu.b=1;
          alu.alufn=b000000;
          correct_count.d=alu.out;
          state.d=state.GET_CORRECT_COUNT;
      
      //To move between levels depending on no of correct count.  
      state.GET_CORRECT_COUNT:
          if (correct_count.q==6){
            state.d=state.WIN;
          }
          else if (correct_count.q==4){
            state.d=state.LEVEL3;
          }
          else if (correct_count.q==2){
            state.d=state.LEVEL2;
          }
          else{
            state.d=state.TEMP_WIN;
        }
      
      //Decrease live by 1 because the player guessed wrong letter.  
      state.SUBTRACT_LIVES:
          alu.a=lives.q;
          alu.b=1;
          alu.alufn=b000001;  //Subtraction
          lives.d=alu.out;
          state.d=state.GET_LIVES;
        
      //If lives == 0 : lose. Else: go to INSERT state.  
      state.GET_LIVES:
          if (lives.q==2b00){  
            state.d=state.LOSE;
          }
          else{
            state.d=state.INSERT;
          }
    }
    
}